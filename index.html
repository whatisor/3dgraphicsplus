<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js ar - hit test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<video id="video" autoplay="true" style="display: none;"></video>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - hit test<br />(Chrome Android
		81+)
	</div>
	<div id="container"></div>
	<canvas id="2d" style="display:none;position:absolute;top:0;left:0;z-index: 1;"></canvas>
	<button onclick="capture(); "style="position:absolute;bottom:0;left:0;z-index: 1;">Capture</button>
	<script type="module">

		import * as THREE from './three.module.js';
		import { ARButton } from './ARButton.js';
		import { OrbitControls } from './OrbitControls.js';
		import { GLTFLoader } from './GLTFLoader.js';
		import { RGBELoader } from './RGBELoader.js';
		import { RoughnessMipmapper } from './RoughnessMipmapper.js';
		import { TWEEN } from './tween.module.min.js';


		var container;
		var camera, scene, renderer;
		var controller;

		var reticle;

		var hitTestSource = null;
		var hitTestSourceRequested = false;
		var sprite, sprite2
		var selectables = []

		init();
		animate();

		function init() {


			container = document.getElementById('container');
			//document.body.appendChild( container );

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

			var light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
			light.position.set(0.5, 1, 0.25);
			scene.add(light);

			//sample sprite
			const map = new THREE.TextureLoader().load('assests/avater2.png');
			const material = new THREE.SpriteMaterial({ map: map });

			sprite = new THREE.Sprite(material);
			sprite.scale.set(0.2, 0.2, 0.2);
			sprite.position.y = 0.7;
			sprite.position.x = 0.5;

			//

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
			renderer.xr.enabled = true;

			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1;
			renderer.outputEncoding = THREE.sRGBEncoding;
			container.appendChild(renderer.domElement);

			const pmremGenerator = new THREE.PMREMGenerator(renderer);
			pmremGenerator.compileEquirectangularShader();

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', render); // use if there is no animation loop
			controls.minDistance = 2;
			controls.maxDistance = 10;
			controls.target.set(0, 0, - 0.2);
			controls.update();

			container.appendChild(renderer.domElement);

			//

			document.body.appendChild(ARButton.createButton(renderer, {
				requiredFeatures: ['hit-test'],
				optionalFeatures: ["dom-overlay", 'dom-overlay-for-handheld-ar'],
				domOverlay: {
					root: document.body
				}
			}));

			//

			var target = new THREE.Group();
			var placed = false;
			function onSelect(event) {

				if (reticle.visible && !placed) {


					target.position.setFromMatrixPosition(reticle.matrix);
					placed = true;

				}

			}

			controller = renderer.xr.getController(0);
			controller.addEventListener('select', onSelect);
			scene.add(controller);

			reticle = new THREE.Mesh(
				new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(- Math.PI / 2),
				new THREE.MeshBasicMaterial()
			);
			reticle.matrixAutoUpdate = false;
			reticle.visible = false;
			scene.add(reticle);



			//Test 3D
			test3D();
			function test3D() {
				new RGBELoader()
					.setDataType(THREE.UnsignedByteType)
					.setPath('assests/')
					.load('royal_esplanade_1k.hdr', function (texture) {

						const envMap = pmremGenerator.fromEquirectangular(texture).texture;

						//scene.background = envMap;
						scene.environment = envMap;

						texture.dispose();
						pmremGenerator.dispose();

						render();

						// model

						// use of RoughnessMipmapper is optional
						const roughnessMipmapper = new RoughnessMipmapper(renderer);

						const loader = new GLTFLoader().setPath('assests/');
						loader.load('DamagedHelmet.gltf', function (gltf) {

							gltf.scene.traverse(function (child) {

								if (child.isMesh) {

									// TOFIX RoughnessMipmapper seems to be broken with WebGL 2.0
									// roughnessMipmapper.generateMipmaps( child.material );

								}

							});
							target.add(gltf.scene);
							target.add(sprite);
							selectables.push(sprite);
							sprite2 = sprite.clone();
							sprite2.material = sprite.material.clone();
							target.add(sprite2);
							sprite2.position.x = 0;
							selectables.push(sprite2);

							var bbox = new THREE.Box3().setFromObject(gltf.scene);
							gltf.scene.scale.set(0.3, 0.3, 0.3);
							gltf.scene.position.y -= bbox.min.y * gltf.scene.scale.y;
							//gltf.scene.position.z = -1.0;
							scene.add(target);

							roughnessMipmapper.dispose();

							render();

						});

					});
			}

			//

			window.addEventListener('resize', onWindowResize, false);

			window.addEventListener("mousemove", onDocumentMouseMove, false);
			window.addEventListener("click", onDocumentMouseDown, false);
			window.addEventListener("touchstart", onDocumentTouchDown, false);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		let selectedObject = null;

		function onDocumentMouseMove(event) {

			//event.preventDefault();
			if (selectedObject) {

				selectedObject.material.color.set('#69f');
				selectedObject = null;

			}

			const intersects = getIntersects(event.layerX ? event.layerX : event.touches[0].clientX,
				event.layerY ? event.layerY : event.touches[0].clientY);

			if (intersects.length > 0) {

				const res = intersects.filter(function (res) {

					return res && res.object;

				})[0];

				if (res && res.object) {

					selectedObject = res.object;
					selectedObject.material.color.set('#f00');

				}

			}

		}


		function onDocumentMouseDown(event) {
			//capture();
			//event.preventDefault();
			if (selectedObject) {
				//showtime();
				//selectedObject = null;
			}
		}

		function onDocumentTouchDown(event) {

			//event.preventDefault();
			onDocumentMouseMove(event);
			onDocumentMouseDown(event);
		}


		const raycaster = new THREE.Raycaster();
		const mouseVector = new THREE.Vector3();

		function getIntersects(x, y) {
			scene.updateMatrixWorld(true);
			x = (x / window.innerWidth) * 2 - 1;
			y = - (y / window.innerHeight) * 2 + 1;

			mouseVector.set(x, y, 0.5);
			var xrcam = camera;
			if (renderer.xr.getSession())
				xrcam = renderer.xr.getCamera(camera);
			raycaster.setFromCamera(mouseVector, xrcam);

			return raycaster.intersectObjects(selectables, true);

		}

		function showtime() {
			// var dis = 1;
			// var duration = 1000;
			// var movingup = new TWEEN.Tween(sprite.parent.position).to(
			// 	new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5),
			// 	duration).easing(TWEEN.Easing.Quadratic.InOut).start();
			// var rotation = new TWEEN.Tween(sprite.parent.rotation).to(
			// 	new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5),
			// 	duration).easing(TWEEN.Easing.Quadratic.InOut).delay(500).start();

			capture();
		}

		function capture() {
			//hack threejs			
			renderer.setFramebuffer(null);
			renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830

			if (renderer.xr.getSession())
				renderer.render(scene, renderer.xr.getCamera(camera));
			var img = renderer.domElement.toDataURL('image/jpeg', 0.8);

			//exit AR
			if (renderer.xr.getSession())
				renderer.xr.getSession().end();

			setTimeout(openFullscreen, 500);
			setTimeout(cameraPreview, 700);

			//saveFile(img, "Captured.jpg");
		}
		window.capture = capture;
		var saveFile = function (strData, filename) {
			var link = document.createElement('a');
			if (typeof link.download === 'string') {
				document.body.appendChild(link); //Firefox requires the link to be in the body
				link.download = filename;
				link.href = strData;

				window.removeEventListener("click", onDocumentMouseDown);
				link.click();
				document.body.removeChild(link); //remove the link when done
			} else {
				location.replace(uri);
			}
		}

		function cameraPreview() {

			var video = document.getElementById('video');

			if (navigator.mediaDevices.getUserMedia) {
				var successCallback = function (stream) {
					video.srcObject = stream;
				};
				var errorCallback = function (error) {
					console.log(error);
				};
				navigator.mediaDevices.getUserMedia({
					audio: false,
					video: { facingMode: { ideal: 'environment' } } // prefer rear-facing camera
				}).then(successCallback, errorCallback);
			}


			var canvas = document.getElementById("2d");
			canvas.style.display = "block";
			canvas.width = renderer.domElement.offsetWidth;
			canvas.height = renderer.domElement.offsetHeight;
			var context = canvas.getContext('2d');
			renderFrame();
			function calculateSize(srcSize, dstSize) {
				var srcRatio = srcSize.width / srcSize.height;
				var dstRatio = dstSize.width / dstSize.height;
				if (dstRatio > srcRatio) {
					return {
						width: dstSize.height * srcRatio,
						height: dstSize.height
					};
				} else {
					return {
						width: dstSize.width,
						height: dstSize.width / srcRatio
					};
				}
			}
			function renderFrame() {
				// re-register callback
				requestAnimationFrame(renderFrame);
				// set internal canvas size to match HTML element size
				canvas.width = canvas.scrollWidth;
				canvas.height = canvas.scrollHeight;
				if (video.readyState === video.HAVE_ENOUGH_DATA) {
					// scale and horizontally center the camera image
					var videoSize = { width: video.videoWidth, height: video.videoHeight };
					var canvasSize = { width: canvas.width, height: canvas.height };
					var renderSize = videoSize;//calculateSize(videoSize, canvasSize);
					var xOffset = (canvasSize.width - renderSize.width) / 2;
					var yOffset = (canvasSize.height - renderSize.height) / 2;
					context.drawImage(video, xOffset, yOffset, videoSize.width, videoSize.height);
				}
			}
		}


		//

		function animate() {

			renderer.setAnimationLoop(render);

		}

		function render(timestamp, frame) {

			if (frame) {

				var referenceSpace = renderer.xr.getReferenceSpace();
				var session = renderer.xr.getSession();

				if (hitTestSourceRequested === false) {

					session.requestReferenceSpace('viewer').then(function (referenceSpace) {

						session.requestHitTestSource({ space: referenceSpace }).then(function (source) {

							hitTestSource = source;

						});

					});

					session.addEventListener('end', function () {

						hitTestSourceRequested = false;
						hitTestSource = null;



					});

					hitTestSourceRequested = true;

				}

				if (hitTestSource) {

					var hitTestResults = frame.getHitTestResults(hitTestSource);

					if (hitTestResults.length) {

						var hit = hitTestResults[0];

						reticle.visible = true;
						reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);

					} else {

						reticle.visible = false;

					}

				}

			}

			renderer.render(scene, camera);


			if (TWEEN) {
				TWEEN.update();
			}

		}
		window.openFullscreen = function(){
					var elem = document.body;
					if (elem.requestFullscreen) {
						elem.requestFullscreen();
					} else if (elem.mozRequestFullScreen) { /* Firefox */
						elem.mozRequestFullScreen();
					} else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
						elem.webkitRequestFullscreen();
					} else if (elem.msRequestFullscreen) { /* IE/Edge */
						elem.msRequestFullscreen();
					}
					elem.style.width = '100%';
					elem.style.height = '100%';
				}

	</script>
</body>

</html>