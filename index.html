<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js ar - hit test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> ar - hit test<br />(Chrome Android
		81+)
	</div>
	<div id="container"></div>
	<script type="module">

		import * as THREE from './three.module.js';
		import { ARButton } from './ARButton.js';
		import { OrbitControls } from './OrbitControls.js';
		import { GLTFLoader } from './GLTFLoader.js';
		import { RGBELoader } from './RGBELoader.js';
		import { RoughnessMipmapper } from './RoughnessMipmapper.js';
		import { TWEEN } from './tween.module.min.js';


		var container;
		var camera, scene, renderer;
		var controller;

		var reticle;

		var hitTestSource = null;
		var hitTestSourceRequested = false;
		var sprite,sprite2
		var selectables = []

		init();
		animate();

		function init() {

			container = document.getElementById('container');
			//document.body.appendChild( container );

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

			var light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
			light.position.set(0.5, 1, 0.25);
			scene.add(light);

			//sample sprite
			const map = new THREE.TextureLoader().load('assests/avater2.png');
			const material = new THREE.SpriteMaterial({ map: map });

			sprite = new THREE.Sprite(material);
			sprite.scale.set(0.2, 0.2, 0.2);
			sprite.position.y = 0.7;
			sprite.position.x = 0.5;

			//

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.xr.enabled = true;

			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1;
			renderer.outputEncoding = THREE.sRGBEncoding;
			container.appendChild(renderer.domElement);

			const pmremGenerator = new THREE.PMREMGenerator(renderer);
			pmremGenerator.compileEquirectangularShader();

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', render); // use if there is no animation loop
			controls.minDistance = 2;
			controls.maxDistance = 10;
			controls.target.set(0, 0, - 0.2);
			controls.update();

			container.appendChild(renderer.domElement);

			//

			document.body.appendChild(ARButton.createButton(renderer, {
				requiredFeatures: ['hit-test'],
				optionalFeatures: ["dom-overlay", 'dom-overlay-for-handheld-ar'],
				domOverlay: {
					root: document.body
				}
			}));

			//

			var target = new THREE.Group();
			var placed = false;
			function onSelect(event) {

				if (reticle.visible && !placed) {

					
					target.position.setFromMatrixPosition(reticle.matrix);
					placed  =true;

				}

			}

			controller = renderer.xr.getController(0);
			controller.addEventListener('select', onSelect);
			scene.add(controller);

			reticle = new THREE.Mesh(
				new THREE.RingBufferGeometry(0.15, 0.2, 32).rotateX(- Math.PI / 2),
				new THREE.MeshBasicMaterial()
			);
			reticle.matrixAutoUpdate = false;
			reticle.visible = false;
			scene.add(reticle);



			//Test 3D
			test3D();
			function test3D() {
				new RGBELoader()
					.setDataType(THREE.UnsignedByteType)
					.setPath('assests/')
					.load('royal_esplanade_1k.hdr', function (texture) {

						const envMap = pmremGenerator.fromEquirectangular(texture).texture;

						//scene.background = envMap;
						scene.environment = envMap;

						texture.dispose();
						pmremGenerator.dispose();

						render();

						// model

						// use of RoughnessMipmapper is optional
						const roughnessMipmapper = new RoughnessMipmapper(renderer);

						const loader = new GLTFLoader().setPath('assests/');
						loader.load('DamagedHelmet.gltf', function (gltf) {

							gltf.scene.traverse(function (child) {

								if (child.isMesh) {

									// TOFIX RoughnessMipmapper seems to be broken with WebGL 2.0
									// roughnessMipmapper.generateMipmaps( child.material );

								}

							});
							target.add(gltf.scene);
							target.add(sprite);
							selectables.push(sprite);
							sprite2 = sprite.clone();
							sprite2.material = sprite.material.clone();
							target.add(sprite2);
							sprite2.position.x = 0;
							selectables.push(sprite2);

							var bbox = new THREE.Box3().setFromObject(gltf.scene);
							gltf.scene.scale.set(0.3, 0.3, 0.3);
							gltf.scene.position.y -= bbox.min.y * gltf.scene.scale.y;
							//gltf.scene.position.z = -1.0;
							scene.add(target);

							roughnessMipmapper.dispose();

							render();

						});

					});
			}

			//

			window.addEventListener('resize', onWindowResize, false);

			window.addEventListener("mousemove", onDocumentMouseMove, false);
			window.addEventListener("click", onDocumentMouseDown, false);
			window.addEventListener("touchstart", onDocumentTouchDown, false);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		let selectedObject = null;

		function onDocumentMouseMove(event) {

			//event.preventDefault();
			if (selectedObject) {

				selectedObject.material.color.set('#69f');
				selectedObject = null;

			}

			const intersects = getIntersects(event.layerX?event.layerX:event.touches[0].clientX,
			 event.layerY?event.layerY:event.touches[0].clientY);

			if (intersects.length > 0) {

				const res = intersects.filter(function (res) {

					return res && res.object;

				})[0];

				if (res && res.object) {

					selectedObject = res.object;
					selectedObject.material.color.set('#f00');

				}

			}

		}


		function onDocumentMouseDown(event) {

			//event.preventDefault();
			if (selectedObject) {
				showtime();
			}
		}

		function onDocumentTouchDown(event) {

			//event.preventDefault();
			onDocumentMouseMove(event);
			onDocumentMouseDown(event);
		}


		const raycaster = new THREE.Raycaster();
		const mouseVector = new THREE.Vector3();

		function getIntersects(x, y) {
			scene.updateMatrixWorld(true);
			x = (x / window.innerWidth) * 2 - 1;
			y = - (y / window.innerHeight) * 2 + 1;

			mouseVector.set(x, y, 0.5);
			raycaster.setFromCamera(mouseVector, renderer.xr.getCamera(camera));

			return raycaster.intersectObjects(selectables, true);

		}

		function showtime() {
			var dis = 1;
			var duration = 1000;
			var movingup = new TWEEN.Tween(sprite.parent.position).to(
				new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5),
				duration).easing(TWEEN.Easing.Quadratic.InOut).start();
			var rotation = new TWEEN.Tween(sprite.parent.rotation).to(
				new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5),
				duration).easing(TWEEN.Easing.Quadratic.InOut).delay(500).start();
		}

		//

		function animate() {

			renderer.setAnimationLoop(render);

		}

		function render(timestamp, frame) {

			if (frame) {

				var referenceSpace = renderer.xr.getReferenceSpace();
				var session = renderer.xr.getSession();

				if (hitTestSourceRequested === false) {

					session.requestReferenceSpace('viewer').then(function (referenceSpace) {

						session.requestHitTestSource({ space: referenceSpace }).then(function (source) {

							hitTestSource = source;

						});

					});

					session.addEventListener('end', function () {

						hitTestSourceRequested = false;
						hitTestSource = null;

					});

					hitTestSourceRequested = true;

				}

				if (hitTestSource) {

					var hitTestResults = frame.getHitTestResults(hitTestSource);

					if (hitTestResults.length) {

						var hit = hitTestResults[0];

						reticle.visible = true;
						reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);

					} else {

						reticle.visible = false;

					}

				}

			}

			renderer.render(scene, camera);


			if (TWEEN) {
				TWEEN.update();
			}

		}

	</script>
</body>

</html>